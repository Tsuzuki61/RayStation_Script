# -*- coding: utf-8 -*-
"""LogFileAnalysis.ipynb

Automatically generated by Colaboratory.

# **ログファイルからDataFrameを作成しpickle化して保存するPythonファイル**
"""

import math
import pandas as pd
import numpy as np
import csv
import os
import glob
import re
import datetime
#Adding notes in RayStation 2023/10/28
import sys



from concurrent.futures import ProcessPoolExecutor
import itertools


def RangeToEnergy(water_range):
    x1 = 5.5919E-01
    x2 = -4.0274E-03
    x3 = 1.5739E-03
    intercept = 3.4658
    return math.exp((x3 * pow(math.log(water_range), 3)) + (x2 * pow(math.log(water_range), 2)) + (
            x1 * math.log(water_range)) + intercept)


def EnergyToRange(energy):
    return math.exp(
        -0.013296 * pow(math.log(energy), 3) + 0.15248 * pow(math.log(energy), 2) + 1.2193 * math.log(energy) - 5.5064)


def create_record_and_specif_dataframe(directory_path):
    if directory_path == "":
        return
    re_record_compile = re.compile(r'.*[0-9]{8}_[0-9]{6}_[0-9]{3}\.burst_record_([0-9]{3})_part_([0-9]{2})\.csv')
    file_list = [p for p in glob.glob(os.path.join(directory_path, '*')) if
                 re_record_compile.search(p)]
    file_list.sort()
    record_df_list = []
    specif_df_list = []
    beam_config_file_name = re.sub(r'burst_record_([0-9]{3})_part_([0-9]{2})', r'beam_config', file_list[0])
    prefix_match = re.search(r'.*([0-9]{8}_[0-9]{6}_[0-9]{3})\.burst_record_[0-9]{3}_part_[0-9]{2}\.csv', file_list[0])
    file_prefix = prefix_match.groups()[0]

    x_pos_iso_rate, y_pos_iso_rate, primary_charge_per_MU = get_beam_config_infomation(beam_config_file_name)
    with ProcessPoolExecutor() as executor:
        rets = executor.map(create_specif_and_record_df, file_list,
                            itertools.repeat(primary_charge_per_MU),
                            itertools.repeat(beam_config_file_name))
    for result in rets:
        specif_df_list.append(result[0])
        record_df_list.append(result[1])
    record_spot_df = pd.concat(record_df_list)
    specif_spot_df = pd.concat(specif_df_list)
    irradiation_record_df = record_spot_df[
        (record_spot_df['SPOT_ID'] > 0) & (record_spot_df['SEC_SPOT_ID'] > 0) & (record_spot_df['#ELEMENT_ID'] > 1)
        & (record_spot_df['MAP_EXEC_STATUS'] == record_spot_df['MAP_EXEC_STATUS_SEC'])]
    irradiation_record_df.loc[:, 'MU_RATE'] = irradiation_record_df['MU'] / irradiation_record_df['MU'].sum()
    irradiation_specif_df = specif_spot_df[(specif_spot_df['SPOT_ID'] > 0) & (specif_spot_df['#ELEMENT_ID'] > 1)]
    irradiation_record_df.loc[:, 'FILE_PREFIX'] = file_prefix
    irradiation_specif_df.loc[:, 'FILE_PREFIX'] = file_prefix

    return irradiation_record_df, irradiation_specif_df


def get_beam_config_infomation(beam_config_file_name):
    with open(beam_config_file_name) as f:
        l_split = [s.strip() for s in f.readlines()]

    x_pos_iso_rate = 0.0
    y_pos_iso_rate = 0.0
    dist_from_ic1_iso_x = 0.0
    dist_from_ic1_iso_y = 0.0
    dist_from_ic2_iso_x = 0.0
    dist_from_ic2_iso_y = 0.0
    primary_charge_per_MU = 0.0
    for i in range(len(l_split)):
        ic1_match = re.search(
            r'CGTR;distanceFromIc1ToIsocenter;Distance from Ic1 to Isocenter \(X,Y\);([0-9]*\.[0-9]*),([0-9]*\.[0-9]*)',
            l_split[i]
        )
        ic2_match = re.search(
            r'CGTR;distanceFromIcToIsocenter;Distance from Ic2 to Isocenter \(X,Y\);([0-9]*\.[0-9]*),([0-9]*\.[0-9]*)',
            l_split[i]
        )
        primary_charge_per_MU_match = re.search(
            r'CGTR;chargePerMuPrimary;Charge per MU on the primary IC;([-+]?[0-9]+\.?[0-9]+([eE][-+]?[0-9]+))',
            l_split[i]
        )
        if ic1_match:
            dist_from_ic1_iso_x, dist_from_ic1_iso_y = ic1_match.groups()
        if ic2_match:
            dist_from_ic2_iso_x, dist_from_ic2_iso_y = ic2_match.groups()
        if primary_charge_per_MU_match:
            primary_charge_per_MU = float(primary_charge_per_MU_match.groups()[0])
        try:
            x_pos_iso_rate = float(dist_from_ic1_iso_x) / (float(dist_from_ic1_iso_x) - float(dist_from_ic2_iso_x))
            y_pos_iso_rate = float(dist_from_ic1_iso_y) / (float(dist_from_ic1_iso_y) - float(dist_from_ic2_iso_y))
        except:
            continue
        else:
            if primary_charge_per_MU != 0.0:
                break
    return x_pos_iso_rate, y_pos_iso_rate, primary_charge_per_MU


def get_DistICtoISO(beam_config_filename):
    ref_string = 'distanceFromIcToIsocenter'
    with open(beam_config_filename) as f:
        l_split = [s.strip() for s in f.readlines()]
    for line in l_split:
        if ref_string in line:
            DistICtoISOstring = line.split(';')
            DistICtoISOstring = DistICtoISOstring[-1].split(',')
            DistICtoISOX = float(DistICtoISOstring[0])
            DistICtoISOY = float(DistICtoISOstring[1])
    return DistICtoISOX, DistICtoISOY


def read_SAD_S2C2(data, config_filename):
    '''CGTR;SAD_IC_X;SAD IC X parameter a, b, c, d, e, f, g, h, i, j according scanalgo spec:
     a * deflX ^ 3 + b * deflY ^ 3 + c * deflX ^ 2 * deflY + d * deflX * deflY ^ 2 + e * deflX ^ 2 + f * deflY ^ 2 + g * deflX * deflY + h * deflX + i * deflY + j;
    '''
    SADX = None
    SADY = None
    ref_string = ['SAD_IC_X', 'SAD_IC_Y']
    if 'PRIM_IC_X_POSITION' in list(data.index):
        deflX = float(data['PRIM_IC_X_POSITION'])
        deflY = float(data['PRIM_IC_Y_POSITION'])
    else:
        deflX = float(data['PRIM_EXP_IC_X_POSITION'])
        deflY = float(data['PRIM_EXP_IC_Y_POSITION'])

    with open(config_filename) as config_file:
        l_split = [s.strip() for s in config_file.readlines()]
    for line in l_split:
        if ref_string[0] in line and 'according scanalgo' in line:
            SADstringX = line.split(':')
            SADparamsX = SADstringX[0].split(';')
            if len(SADstringX) == 1:
                SADX = float(SADparamsX[-1])
            else:
                param_match = re.search(r'parameter ([a-z,]+) according', line)
                if param_match:
                    SADXcoefs_val = param_match.group(1).split(',')
                SADXcoefs = line.split(';')[-1].split(',')
                SADXfunc_string = line.split(':')[1].split(';')[0]
                SADXfunc_string = SADXfunc_string.replace('^', '**')

                for val, coef in zip(SADXcoefs_val, SADXcoefs):
                    exec(val + '=' + 'float(' + coef + ')')
                SADX = eval(SADXfunc_string)
        elif ref_string[1] in line and 'according scanalgo' in line:
            SADstringY = line.split(':')
            SADparamsY = SADstringY[0].split(';')
            if len(SADstringY) == 1:
                SADY = float(SADparamsY[-1])
            else:
                param_match = re.search(r'parameter ([a-z,]+) according', line)
                if param_match:
                    SADYcoefs_val = param_match.group(1).split(',')
                SADYcoefs = line.split(';')[-1].split(',')
                SADYfunc_string = line.split(':')[1].split(';')[0]
                SADYfunc_string = SADYfunc_string.replace('^', '**')
                for val, coef in zip(SADYcoefs_val, SADYcoefs):
                    exec(val + '=' + 'float(' + coef + ')')
                SADY = eval(SADYfunc_string)
        if SADX is not None and SADY is not None:
            break
    return float(SADX), float(SADY)


def project_on_iso_plane_x_y(data, config_filename, axis):
    'Project on isocenter plane using formula: -SMOffset + (Position_IC ? ICOffset)*SAD_IC/(SAD_IC - distanceFromICtoIso)'
    SADX, SADY = read_SAD_S2C2(data, config_filename)
    DistICtoISOX, DistICtoISOY = get_DistICtoISO(config_filename)
    if 'PRIM_IC_X_POSITION' in list(data.index):
        if axis == "x":
            return -data['SMX_OFFSET'] + (data['PRIM_IC_X_POSITION'] - data['ICX_OFFSET']) * SADX / (
                    SADX - DistICtoISOX)
        else:
            return -data['SMY_OFFSET'] + (data['PRIM_IC_Y_POSITION'] - data['ICY_OFFSET']) * SADY / (
                    SADY - DistICtoISOY)
    else:
        if axis == "x":
            return -data['SMX_OFFSET'] + (data['PRIM_EXP_IC_X_POSITION'] - data['ICX_OFFSET']) * SADX / (
                    SADX - DistICtoISOX)
        else:
            return -data['SMY_OFFSET'] + (data['PRIM_EXP_IC_Y_POSITION'] - data['ICY_OFFSET']) * SADY / (
                    SADY - DistICtoISOY)


def calculate_start_datetime(data, start_irradiation, start_fpga_count):
    return start_irradiation + datetime.timedelta(microseconds=float(data) - start_fpga_count)


def create_specif_and_record_df(file, primary_charge_per_MU, beam_config_filename):
    re_record_compile = re.compile(r'.*[0-9]{8}_[0-9]{6}_[0-9]{3}\.burst_record_([0-9]{3})_part_([0-9]{2})\.csv')
    first_index = 0
    layer_number = re_record_compile.search(file).groups()[0]
    burst_number = re_record_compile.search(file).groups()[1]
    specif_file = re.sub(r'burst_record', r'burst_specif', file)
    Range = 0.0
    with open(specif_file) as f:
        specif_reader = csv.reader(f)
        reader_list = [row for row in specif_reader]
        for i in range(len(reader_list)):
            if i >= 1:
                if len(reader_list[i]) > 0 and reader_list[i][1] == 'RANGE':
                    Range = reader_list[i + 1][1]
                elif len(reader_list[i]) > 0 and reader_list[i][0] == '#DISCARD':
                    for j in range(len(reader_list[i])):
                        if reader_list[i][j] == 'SMX_OFFSET':
                            SMX_OFFSET = reader_list[i + 1][j]
                        if reader_list[i][j] == 'SMY_OFFSET':
                            SMY_OFFSET = reader_list[i + 1][j]
                        if reader_list[i][j] == 'ICX_OFFSET':
                            ICX_OFFSET = reader_list[i + 1][j]
                        if reader_list[i][j] == 'ICY_OFFSET':
                            ICY_OFFSET = reader_list[i + 1][j]
                        if reader_list[i][j] == 'IC1X_OFFSET':
                            IC1X_OFFSET = reader_list[i + 1][j]
                        if reader_list[i][j] == 'IC1Y_OFFSET':
                            IC1Y_OFFSET = reader_list[i + 1][j]
                elif len(reader_list[i]) > 0 and reader_list[i][0] == '#ELEMENT_ID':
                    specif_columns = reader_list[i]
                    specif_first_index = i
                    break
    tmp_specif_df = pd.read_csv(specif_file, header=specif_first_index)
    tmp_specif_df.columns = specif_columns
    tmp_specif_df['RANGE'] = float(Range)
    tmp_specif_df['SMX_OFFSET'] = float(SMX_OFFSET)
    tmp_specif_df['SMY_OFFSET'] = float(SMY_OFFSET)
    tmp_specif_df['ICX_OFFSET'] = float(ICX_OFFSET)
    tmp_specif_df['ICY_OFFSET'] = float(ICY_OFFSET)
    tmp_specif_df['IC1X_OFFSET'] = float(IC1X_OFFSET)
    tmp_specif_df['IC1Y_OFFSET'] = float(IC1Y_OFFSET)
    tmp_specif_df['ENERGY'] = RangeToEnergy(float(Range))
    tmp_specif_df['ISO_X_POSITION'] = tmp_specif_df.apply(project_on_iso_plane_x_y, axis=1,
                                                          args=(beam_config_filename, 'x'))
    tmp_specif_df['ISO_Y_POSITION'] = tmp_specif_df.apply(project_on_iso_plane_x_y, axis=1,
                                                          args=(beam_config_filename, 'y'))
    tmp_specif_df['PRIM_IC_X_WIDTH'] = np.mean(tmp_specif_df[['PRIM_IC_X_WIDTH_MIN', 'PRIM_IC_X_WIDTH_MAX']],
                                               axis=1)
    tmp_specif_df['PRIM_IC_Y_WIDTH'] = np.mean(tmp_specif_df[['PRIM_IC_Y_WIDTH_MIN', 'PRIM_IC_Y_WIDTH_MAX']],
                                               axis=1)
    tmp_specif_df['GROUP'] = 'specif'
    tmp_specif_df['LAYER'] = int(layer_number)
    tmp_specif_df['BURST'] = int(burst_number)
    tmp_specif_df = tmp_specif_df.dropna()
    tmp_specif_df = tmp_specif_df.astype({'#ELEMENT_ID': int})

    with open(file) as record_file:
        reader = csv.reader(record_file)
        reader_list = [row for row in reader]
        for i in range(len(reader_list)):
            if len(reader_list[i]) > 0 and reader_list[i][0] == '#LAYER_ID':
                for j in range(len(reader_list[i])):
                    if reader_list[i][j] == 'START_IRRADIATION':
                        if sys.version_info.major == 0 and sys.version_info.minor >= 7:
                            start_irradiation = datetime.datetime.fromisoformat(reader_list[i + 1][j])
                        else:
                            re_iso_datetime_str = re.sub('([0-9]{2}):([0-9]{2})$',r'\1\2',reader_list[i + 1][j])
                            isoformat_str = '%Y-%m-%dT%H:%M:%S.%f%z'
                            start_irradiation = datetime.datetime.strptime(re_iso_datetime_str,isoformat_str)
                        break
            if len(reader_list[i]) > 0 and reader_list[i][0] == '#DISCARD':
                for j in range(len(reader_list[i])):
                    if reader_list[i][j] == 'SMX_OFFSET':
                        SMX_OFFSET = reader_list[i + 1][j]
                    if reader_list[i][j] == 'SMY_OFFSET':
                        SMY_OFFSET = reader_list[i + 1][j]
                    if reader_list[i][j] == 'ICX_OFFSET':
                        ICX_OFFSET = reader_list[i + 1][j]
                    if reader_list[i][j] == 'ICY_OFFSET':
                        ICY_OFFSET = reader_list[i + 1][j]
                    if reader_list[i][j] == 'IC1X_OFFSET':
                        IC1X_OFFSET = reader_list[i + 1][j]
                    if reader_list[i][j] == 'IC1Y_OFFSET':
                        IC1Y_OFFSET = reader_list[i + 1][j]
            if len(reader_list[i]) > 0 and reader_list[i][0] == '#ELEMENT_ID':
                columns = reader_list[i]
                first_index = i
                break
    tmp_df = pd.read_csv(file, header=first_index)
    tmp_df.columns = columns
    first_irradiation_fpga_count = tmp_df[tmp_df['SPOT_ID'] > 0]['FPGA_COUNT'].astype(float).min()
    tmp_df['START_DATETIME'] = tmp_df['FPGA_COUNT'].apply(calculate_start_datetime,
                                                          args=(start_irradiation, first_irradiation_fpga_count))
    tmp_df['RANGE'] = float(Range)
    tmp_df['ENERGY'] = RangeToEnergy(float(Range))
    tmp_df['SMX_OFFSET'] = float(SMX_OFFSET)
    tmp_df['SMY_OFFSET'] = float(SMY_OFFSET)
    tmp_df['ICX_OFFSET'] = float(ICX_OFFSET)
    tmp_df['ICY_OFFSET'] = float(ICY_OFFSET)
    tmp_df['IC1X_OFFSET'] = float(IC1X_OFFSET)
    tmp_df['IC1Y_OFFSET'] = float(IC1Y_OFFSET)

    tmp_df['ISO_X_POSITION'] = tmp_df.apply(project_on_iso_plane_x_y, axis=1, args=(beam_config_filename, 'x'))
    tmp_df['ISO_Y_POSITION'] = tmp_df.apply(project_on_iso_plane_x_y, axis=1, args=(beam_config_filename, 'y'))
    # tmp_df['ISO_X_POSITION_OFFSET'] = (((tmp_df['PRIM_IC_X_POSITION'] + tmp_df['ICX_OFFSET']) - (
    #         tmp_df['SEC_IC_X_POSITION'] + tmp_df['IC1X_OFFSET'])) * x_pos_iso_rate) + tmp_df['SEC_IC_X_POSITION'] + \
    #                                   tmp_df['IC1X_OFFSET']
    # tmp_df['ISO_Y_POSITION_OFFSET'] = (((tmp_df['PRIM_IC_Y_POSITION'] + tmp_df['ICY_OFFSET']) - (
    #         tmp_df['SEC_IC_Y_POSITION'] + tmp_df['IC1Y_OFFSET'])) * y_pos_iso_rate) + tmp_df['SEC_IC_Y_POSITION'] + \
    #                                   tmp_df['IC1Y_OFFSET']
    tmp_df['GROUP'] = 'record'
    tmp_df['LAYER'] = int(layer_number)
    tmp_df['BURST'] = int(burst_number)
    tmp_df['MU'] = tmp_df['PRIM_IC_CHARGE'].astype(float) / primary_charge_per_MU

    return tmp_specif_df, tmp_df


if __name__ == "__main__":
    # @title specif Fileとrecord Fileをpickle化
    import tkinter as tk
    from tkinter import filedialog

    root = tk.Tk()
    root.withdraw()
    directory = filedialog.askdirectory(initialdir=os.path.expanduser('~/Desktop'))
    if directory == "":
        exit()
    record_df, specif_df = create_record_and_specif_dataframe(directory_path=directory)
    folder_path = r''  # 出力先Directory

    specif_file_name = 'specif_log_dataframe_' + specif_df['FILE_PREFIX'].iat[0] + '.pkl'
    record_file_name = 'record_log_dataframe_' + record_df['FILE_PREFIX'].iat[0] + '.pkl'
    specif_file_path = os.path.join(folder_path, specif_file_name)
    record_file_path = os.path.join(folder_path, record_file_name)
    specif_df.to_pickle(specif_file_path)
    record_df.to_pickle(record_file_path)
